# Command line tool for Condom
#
# Author:: Vivien 'v0n' Didelot <vivien.didelot@gmail.com>
# See:: http://github.com/v0n/condom
#TODO accept 'article|book|report' as a type (seen like 'document').

require 'condom'
require 'optparse'

quiet = false
types = ['document', 'presentation', 'letter']
ops = {:other_packages => []}

ARGV.options do |o|
  o.banner = "Usage: #{File.basename $0} [type] [options]\n"
  o.on_head("\nAvailable types:",
    "    document                         'article', 'report' or other classes",
    "    presentation                     'beamer' class",
    "    letter                           'letter' class",
    "\nAvailable options:")
  o.on("-n", "--filename=FILENAME",    String, "Define a file name")          { |v| ops[:filename] = v }
  o.on("-a", "--author=AUTHOR",        String, "Define the author")           { |v| ops[:author] = v }
  o.on("-t", "--title=TITLE",          String, "Define the title")            { |v| ops[:title] = v }
  o.on("-d", "--date=DATE",            String, "Define the date")             { |v| ops[:date] = v }
  o.on("-c", "--document-class=CLASS", String, "Define the document class")   { |v| ops[:document_class] = v }
  o.on("-l", "--language=LANGUAGE",    String, "Define the language")         { |v| ops[:language] = v }
  o.on("-p", "--package=PACKAGE",      String, "Add another package")         { |v| ops[:other_packages].push v }
  o.on("-o", "--directory=DIRECTORY",  String, "Define the output directory") { |v| ops[:directory] = v }
  o.on("-q", "--quiet",                        "Don't ask any question")      { quiet = true }
  o.on("-v", "--version",                      "Print Condom version")        { puts "Condom: version #{Condom::VERSION}" ; exit }
end

begin
  ARGV.options.parse!
  raise "Bad syntax. Try \`#{File.basename $0} --help' for more information." if ARGV.length > 1

  if ARGV.size == 1
    doc = case ARGV.first
          when 'document' then Condom::Document.new
          when 'presentation' then Condom::Presentation.new
          when 'letter' then Condom::Letter.new
          else raise "Bad syntax. Try \`#{File.basename $0} --help' for more information."
          end
  elsif ops.has_key? :document_class
    doc = case ops[:document_class]
          when 'beamer' then Condom::Presentation.new
          when 'letter' then Condom::Letter.new
          else Condom::Document.new
          end
  else
    doc = Condom::Document.new
  end

  doc.set_options(ops)

  unless quiet
    # Ask for confirmation
    puts "Enter the new value, or press ENTER for the default"

    doc_type = doc.class.to_s.split('::').last.downcase
    printf "    %-17s [%s]: ", "type", doc_type
    type = STDIN.gets.strip
    doc = case type
          when 'document' then Condom::Document.new(ops)
          when 'presentation' then Condom::Presentation.new(ops)
          when 'letter' then Condom::Letter.new(ops)
          else raise "Bad syntax. Try \`#{File.basename $0} --help' for more information."
          end unless type.empty? || type == doc_type
    puts

    loop do
      ops = Hash.new
      doc.get_options.each do |key, value|
        displayed_value = case value
                          when true then "yes"
                          when false then "no"
                          when Array then value.join(', ')
                          else value
                          end
        printf "    %-17s [%s]: ", key, displayed_value
        new_value = STDIN.gets.strip
        ops[key] = if value.is_a?(FalseClass) && new_value == "yes" then true
                   elsif value.is_a?(TrueClass) && new_value == "no" then false
                   elsif key == :other_packages then new_value.split(/\s*,\s*/)
                   else new_value
                   end unless new_value.empty?
      end
      doc.set_options(ops) unless ops.empty?

      print "\nIs the information correct? [Y/n/q] "
      case STDIN.gets.strip
        when /^Y?$/i then break
        when 'q' then exit
      end
    end
  end

  doc.create
  puts "info: Files created in #{doc.directory}."
rescue => e
  STDERR.puts "fail: #{e}"
end

exit
